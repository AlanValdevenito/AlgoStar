¿Como modelar el tema de los ataques?

Pense en que las unidades puedan implementar dos tipos de interfaces
una relacionada al ataque por aire y otra relacionada al ataque por tierra.

¿Como hacer con aquellas unidades que implementan ambas interfaces?.

La clase UnidadDeTierra recibira por parametro ataques por tierra.
La clase UnidadDeAire recibira por parametro ataques por aire.

@startuml

interface Atacable {
    +recibirAtaque()
    +ubicacion(): Ubicacion
    +obtenerSuperficie(): Superficie
    +atacar(unAtacable)
}

note right: Tambien implementan esta interfaz todas las unidades concretas (Zerling, Dragon, etc).

abstract class Raza {
    -tiempo: Tiempo
    -ubicacion: Ubicacion
    +avanzarTurno() {abstract}
    +recibirAtaque() {abstract}
    +ubicacion(): Ubicacion
    +tiempoDeEspera(): int
}

note left: Esta clase abstracta tambien la implementan los edificios.

class Unidad {
    -tipo: TipoDeUnidad
    -estado: TipoDeUnidad
    +Unidad(unTiempo, unaUbicacion, unTipo)
    +cambiarTipo(unTipo)
    +recibirAtaque(unDanio)
    +obtenerSuperficie(): Superficie
    +atacar(unAtacable)
    +avanzarTurno()
}

note right: Inicialmente tenemos\n\nthis.estado = new EnConstruccion()\nthis.tipo = unTipo\n\nCuando se cumpla el tiempo de construccion tendremos\n\nthis.estado = this.tipo
note right: El metodo avanzarTurno() se encargara\nde cambiar el estado si y solo si el tiempo\nde construccion se cumple.

interface TipoDeUnidad {
    +recibirAtaque(unDanio)
    +obtenerSuperficie(): Superficie
    +atacar(unAtacable)
    +recuperarse()
}

class Zerling {
    -vida: Vida
    -Ubicacion: ubicacion
    -Superficie: superficie
    -ataques: ArrayList<Ataque>
    +Zerling(unaUbicacion)
    +recibirAtaque(unDanio)
    +atacar(unAtacable)
    +recuperarse()
    +estaEnRangoDeAtaque(unAtacable, unAtaque): boolean
    +ubicacion(): Ubicacion
    +vidaRestante(): int
    +obtenerSuperficie(): Superficie
}

class Dragon {
    -vida: Vida
    -escudo: Escudo
    -Ubicacion: ubicacion
    -Superficie: superficie
    -ataques: ArrayList<Ataque>
    +Dragon(unaUbicacion)
    +recibirAtaque(unDanio)
    +atacar(unAtacable)
    +recuperarse()
    +estaEnRangoDeAtaque(unAtacable, unAtaque): boolean
    +ubicacion(): Ubicacion
    +vidaRestante(): int
    +escudoRestante(): int
    +obtenerSuperficie(): Superficie
}

class EnConstruccion {
    +EnConstruccion()
    +recibirAtaque(unDanio)
    +atacar(unAtacable)
    +recuperarse()
    +obtenerSuperficie(): Superficie
}

note right: Todos sus metodos no hacen nada o lanzan una excepcion.

Raza ..right|> Atacable
Unidad --up|> Raza
Unidad --down> TipoDeUnidad
Zerling ..up|> TipoDeUnidad
EnConstruccion .up|> TipoDeUnidad
Dragon ..up|> TipoDeUnidad

@enduml

-----------------------------------------------------------------------------------------------------

@startuml

interface Atacable {
    +recibirAtaque()
    +ubicacion(): Ubicacion
    +obtenerSuperficie(): Superficie
    +atacar(unAtacable)
}

abstract class Raza {
    -tiempo: Tiempo
    -ubicacion: Ubicacion
    +avanzarTurno() {abstract}
    +recibirAtaque() {abstract}
    +ubicacion(): Ubicacion
}

class Unidad {
    -tipo: TipoDeUnidad
    +Unidad(unTiempo, unaUbicacion, unTipo)
    +cambiarTipo(unTipo)
    +recibirAtaque(unDanio)
    +obtenerSuperficie(): Superficie
    +atacar(unAtacable)
    +avanzarTurno()
}

interface TipoDeUnidad {
    +recibirAtaque(unDanio)
    +obtenerSuperficie(): Superficie
    +atacar(unAtacable)
    +recuperarse()
}

class Zerling {
    -vida: Vida
    -Ubicacion: ubicacion
    -Superficie: superficie
    -ataques: ArrayList<Ataque>
    +Zerling(unaUbicacion)
    +recibirAtaque(unDanio)
    +atacar(unAtacable)
    +recuperarse()
    +estaEnRangoDeAtaque(unAtacable, unAtaque): boolean
    +ubicacion(): Ubicacion
    +vidaRestante(): int
    +obtenerSuperficie(): Superficie
}

class Dragon {
    -vida: Vida
    -escudo: Escudo
    -Ubicacion: ubicacion
    -Superficie: superficie
    -ataques: ArrayList<Ataque>
    +Dragon(unaUbicacion)
    +recibirAtaque(unDanio)
    +atacar(unAtacable)
    +recuperarse()
    +estaEnRangoDeAtaque(unAtacable, unAtaque): boolean
    +ubicacion(): Ubicacion
    +vidaRestante(): int
    +escudoRestante(): int
    +obtenerSuperficie(): Superficie
}

class Superficie {
    -tipo: String
    +compararCon(otraSuperficie)
}

class Ataque{
    -rango: int
    -tipo: Superficie
    -valor: int
    +Ataque(unDanio, unRango)
    +rango()
    +atacarA(unAtacable)
    +obtenerSuperficie()
}

Raza ..right|> Atacable
Unidad --up|> Raza
Unidad --down> TipoDeUnidad
Zerling ..up|> TipoDeUnidad
Dragon ..up|> TipoDeUnidad
Zerling -> Ataque
Dragon -left> Ataque
Zerling --down> Superficie
Dragon -down> Superficie

@enduml