"Relacion entre las clases principales"
@startuml

class AlgoStar {
    -mapa: Mapa
    -razas: Raza
    -recursos: Recurso
}

class Mapa{
    -ubicaciones: Ubicacion
	+construir(Construccion,Ubicacion)
	+encontrarUbicacionConRequisito(Construccion)
}

abstract class Raza
abstract class Recurso

class Ubicacion{
	-posX: int
	-posY: int
	-elementos:Array
	+sePuedeConstruirEn(Ubicacion)
	+estaDentroDeRadioDeConstruccion()

}

class GasVespeno
class NodoMineral

AlgoStar --> Mapa
AlgoStar --> Raza
AlgoStar --> Recurso
Mapa --> Ubicacion
Recurso <|-- GasVespeno
Recurso <|-- NodoMineral

@enduml

"Supongamos que queremos construir un Criadero Zerg.
Le enviamos un mensaje a AlgoStar para constuir un edificio
le pasamos por parametro una instancia del Criadero y
tambien la ubicacion donde queremos construirlo.
Luego, le va a delegar a la clase Mapa la responsabilidad
de comprobar que efectivamente puede construir en dicha
ubicacion. Si la clase Mapa autoriza, entonces le envia
un mensaje a la clase Zerg para construir. Esta clase
debe comprobar si tiene recursos suficientes para
la construccion. Si efectivamente tiene recursos,
se construye y se guarda en la lista de construcciones
de los Zerg. El edificio comienza como NoUtilizable."

"Supongamos que queremos recolectar Gas.
Le enviamos un mensaje a AlgoStar para recolectar Gas
Vespeno... "

"-------------------------------------------------------"

"Razas"
@startuml

abstract class Raza{
	-vida: Vida
	-construcciones: Construccion
	-unidades: Unidad
	{abstract}+recibirDanio()
}

class Protoss{
	-escudo: Escudo
}

Raza <|-- Zerg
Raza <|-- Protoss

abstract class Unidad
abstract class Construccion

Construccion *-- Raza
Unidad *-- Raza

@enduml

"-------------------------------------------------------"

"Raza Zerg y su relacion con los edificios"
@startuml

abstract class Raza{
	-vida: Vida
	-construcciones: Construccion
	-unidades: Unidad
	{abstract}+recibirDanio()
}

class Zerg
abstract class Construccion
interface EstadoOperativo
class Criadero
class Extractor
class ReservaDeProduccion
class Guarida
class Espiral

Raza <|-- Zerg
Zerg --> Construccion
Construccion <|-- Criadero
Construccion <|-- Extractor
Construccion <|-- ReservaDeProduccion
Construccion <|-- Guarida
Construccion <|-- Espiral

@enduml

"-------------------------------------------------------"

"Criadero"
@startuml

class Criadero {
    -estadoOperativo: EstadoOperativo
    -maxLarvas
    +Criadero(Tiempo, EstadoOperativo)
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTurno()
    +generarLarva(): Larva

}

interface Evolucionable{
	+evolucionar(UnidadRaza)
}

class Larva{
	+evolucionar(): Zangano
}

class Moho{
	-radio:Int
	+expandirse()
}

class Tiempo{
	-cantidad: Int
	+Tiempo(cantidad)
	+avanzarTiempo()
	+tiempo(): Int
}

interface EstadoOperativo{
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTurno()
    +generarLarva(): Larva
}

class CriaderoUtilizable
class CriaderoNoUtilizable

Criadero --> EstadoOperativo
CriaderoUtilizable ..up|> EstadoOperativo
CriaderoNoUtilizable ..up|> EstadoOperativo

Tiempo <-right- Criadero
Larva ..|> Evolucionable
Criadero --> Larva
Criadero o-- Moho

@enduml

"Inicialmente el Criadero comenzara con un estado Operativo
de CriaderoNoUtilizable.
Si quisieramos pedirle a Criadero que cuenta las larvas,
dentro del metodo contarLarvas() hariamos algo como

estadoOperativo contarLarvas()

y utilizando de esta forma polimorfismo dependiendo
de su estado (que cambiara en tiempo de ejecucion)
la respuesta al mensaje sera diferente.
Estamos delegando en el estadoOperativo."

"--------------------------------------------------------"

"Raza Protoss y su relacion con los edificios"
@startuml

abstract class Raza{
	-vida: Vida
	-construcciones: Construccion
	-unidades: Unidad
	{abstract}+recibirDanio()
}

class Protoss
abstract class Construccion
class NexoMineral
class Pilon
class Asimilador
class Acceso
class PuertoEstelar

Raza <|-- Protoss
Protoss --> Construccion
Construccion <|-- NexoMineral
Construccion <|-- Pilon
Construccion <|-- Asimilador
Construccion <|-- Acceso
Construccion <|-- PuertoEstelar

@enduml

"--------------------------------------------------------"

"Recursos"
@startuml

class Mineral{
	-unidad: Unidad
	+disminuirUnidades(cantidad)
}
class Nodo
abstract class Gas
class Vespeno
class Volcan{
	-edificio: Construccion
	+Volcan(EdificioVacio)
	+construir(Construccion edificio)
	+extraerGas()
	+extraer(cantidadAExtraer)
}

class Geiser

interface Recolectable

Gas <|-- Vespeno


abstract class Unidad{
	-cantidad
	+Unidad(cantidad)
}

class Turno{
	- tie
}

@enduml

"--------------------------------------------------------"

"Edificios Zerg"
@startuml

interface Construible{
	+construir()
}
interface Destruible
interface Daniable
interface Recuperable
interface Evolucionable{
	+evolucionar(UnidadRaza)
}
interface Mutable
interface Creable
interface Edificable
interface Habilitable
interface Transformable

class Unidad
class Larva{
	+evolucionar(): Zangano
}

class Zangano
class Construccion
class Moho{
	-radio:Int
	+expandirse()
}
abstract class Criadero {
    -maxLarvas
    +Criadero(Tiempo)
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTurno()
    +generarLarva(): Larva
}

Criadero <|-- CriaderoUtilizable
Criadero <|-- CriaderoNoUtilizable

class Tiempo{
	-cantidad: Int
	+Tiempo(cantidad)
	+avanzarTiempo()
	+tiempo(): Int
}


Tiempo <-right- Criadero

Larva ..|> Evolucionable
Criadero --> Larva

abstract class RefineriaDeGas{
	-extraible:Int
	+RefineriaDeGas(cantidad)
	+extraerGas(Volcan)
}

class Extractor{
	-zanganos:Array<Zangano>
}

Extractor "1" --> Zangano

class Asimilador{
}

RefineriaDeGas <|--Extractor
RefineriaDeGas <|--Asimilador
class ReservaDeProduccion
class Guarida
class Espiral

Criadero o-- Moho

@enduml

"--------------------------------------------------------"


"Clases que tienen unidades que se gastan"
@startuml

abstract class Consumible{
	-cantidad: Int
}
Consumible <|-- Tiempo
Consumible <|-- Vida
Consumible <|-- Unidad
Consumible <|-- Escudo

class Tiempo{
	+Tiempo(cantidad: int)
	+pasarTiempo()
}

class Vida
class Unidad{
	
}
class Escudo

interface Consumible2

@enduml

"--------------------------------------------------------"


" Edificios Protoss"
@startuml

class Escudo
class Vida
class Pilon
class RadioDeAlcance
class NexoMineral
class MatrizPsi
class Asimilador
class CapsulaDeGas
class Acceso
class GrietaDistorcion
class Entrada
class Tropa
class Aiur
class PuertoEstelar


interface Daniable
interface Recuperable
interface Construible
interface Destruible
interface Edificable
interface Energizable
interface Emitible
interface Producible
interface Entrenable
interface Transportable


@enduml

"--------------------------------------------------------"


@startuml

abstract class Construccion

abstract class Criadero{
	+{abstract}metodo1()
	+{abstract}metodo2()
}
class CriaderoUtilizable
class CriaderoNoUtilizable

Construccion <|-- Utilizable
Construccion <|-- NoUtilizable

@enduml

"--------------------------------------------------------"

@startuml

Usuario->Mapa: construir(Construccion, Ubicacion)
	loop para cada ubicacion
		Mapa->Mapa: ubicacionBuscada = encontrarUbicacion(Ubicacion)
	end
	Mapa->Ubicacion:puedoConstruirEnEstaUbicacion()
	Ubicacion-->Mapa:true
	Mapa->Ubicacion: puedoConstruirEsteEdificio(Construccion)
	Ubicacion->Construccion: dameLoQueNecesitasParaConstruirte()
	Construccion-->Ubicacion: Moho/Pilon
	Ubicacion->Ubicacion: tengo(Moho/Pilon)
	Ubicacion-->Mapa:true
	Mapa->Ubicacion:crear(Construccion)
	
@enduml

"--------------------------------------------------------"

@startuml

Usuario->Mapa: construir(Construccion, Ubicacion)
	loop para cada ubicacion
		Mapa->Mapa: conRequisito = encontrarUbicacionConRequisito(Construccion)
	end
	loop para cada ubicacion con moho
		Mapa->Ubicacion:sePuedeConstruirEn(Ubicacion)
		Ubicacion->Ubicacion: estaDentroDeRadioDeConstruccion()
		Ubicacion-->Mapa:true
	end
	Mapa->Ubicacion:crear(Construccion)
	
@enduml

"--------------------------------------------------------"