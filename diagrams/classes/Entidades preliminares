"Relacion entre las clases principales"
@startuml

class AlgoStar {
    -mapa: Mapa
    -razas: Raza
    -recursos: Recurso
}

class Mapa{
    -ubicaciones: Ubicacion
	+construir(Construccion,Ubicacion)
	+encontrarUbicacionConRequisito(Construccion)
}

abstract class Raza{
    -construcciones: Construccion
    +guardarConstruccion()
}
abstract class Recurso

class Ubicacion{
	-posX: int
	-posY: int
	-elementos:Array
	+sePuedeConstruirEn(Ubicacion)
	+estaDentroDeRadioDeConstruccion()

}

class Volcan
class NodoMineral {
    -cantidadDeMineral: int
}

AlgoStar --> Mapa
AlgoStar --> Raza
AlgoStar --> Recurso
Mapa --> Ubicacion
Recurso <|-- Volcan
Recurso <|-- NodoMineral

@enduml

"Supongamos que queremos construir un Criadero Zerg.
Inicializamos una instancia de Criadero y Ubicacion.
Le enviamos un mensaje a AlgoStar para constuir un edificio
y le pasamos por parametro una instancia del Criadero y
tambien la ubicacion donde queremos construirlo.
Luego, le va a delegar a la clase Mapa la responsabilidad
de comprobar que efectivamente puede construir en dicha
ubicacion. Si la clase Mapa autoriza, entonces AlgoStar le envia
un mensaje a la clase Zerg para guardar su construccion. Esta clase
debe comprobar si tiene recursos suficientes para
la construccion. Si efectivamente tiene recursos,
se guarda en la lista de construcciones
de los Zerg. El edificio comienza como NoUtilizable."

"Supongamos que queremos construir Extractor.
Inicializamos una instancia de Extractor y Ubicacion.
Le enviamos un mensaje a AlgoStar para construir un edificio
y le pasamos por parametro una instancia del Extractor y
tambien la ubicacion donde queremos construirlo.
Luego, le va a delegar a la clase Mapa la responsabilidad
de comprobar que efectivamente puede construir en dicha
ubicacion. Si la clase Mapa autoriza, entonces AlgoStar le envia
un mensaje a la clase Volcan para construir un Extractor allÃ­.
Si se autoriza, entonces la clase AlgoStar le envia un mensaje
a Raza para guardar su construccion, la cual solo se guardara si
tiene la cantidad de materiales suficientes.

La clase Volcan tendra que recibir una instancia de la
clase del tipo Extractor en su constructor, sino
lanza excepcion.
Si es del tipo Extractor, entonces Volcan se guarda
como atributo al Extractor."

"Supongamos que queremos recolectar Gas.
Le enviamos un mensaje a AlgoStar para recolectar Gas
Vespeno... "

"-------------------------------------------------------"

"Recursos: Gas"
@startuml

class GasVespeno{
    -cantidad: int
}

class Volcan{
	-edificio: Construccion
	+Volcan(EdificioVacio)
	+construir(Construccion edificio)
	+extraerGas()
	+extraer(cantidadAExtraer)
}

abstract class RefineriaDeGas{
	-cantidadExtraible: int
	+RefineriaDeGas(cantidad)
	+extraerGas(Volcan)
}

class Extractor{
	-zanganos: Zangano
	+guardarZangano(unZangano)
}

class Asimilador{
}

RefineriaDeGas <|--Extractor
RefineriaDeGas <|--Asimilador

Volcan --> GasVespeno
Volcan --> RefineriaDeGas

@enduml

"Supongamos que queremos construir un Extractor.
El Volcan recibira en su constructor una instancia
de la clase Extractor con un estado operativo inicial
de ExtractorNoUtilizable.
Entonces el Volcan se guardara como atributo al Extractor."

"Supongamos que queremos recolectar Gas utilizando un Extractor.
Le enviamos un mensaje a Volcan diciendole que queremos extraer
gas. El Volcan le delega al Extractor la responsabilidad
de calcular la cantidad de gas a extraer.
Extractor recorre su lista de Zanganos y suma
Extractor le pide la cantidad de gas al Volcan y este
le devuelve la cantidad que tiene disponible.
Luego el Volcan devuelve la cantidad extraida de gas."

"-------------------------------------------------------"

"Razas"
@startuml

abstract class Raza{
	-vida: Vida
	-construcciones: Construccion
	-unidades: Unidad
	{abstract}+recibirDanio()
}

class Protoss{
	-escudo: Escudo
}

Raza <|-- Zerg
Raza <|-- Protoss

abstract class Unidad
abstract class Construccion

Construccion *-- Raza
Unidad *-- Raza

@enduml

"-------------------------------------------------------"

"Raza Zerg y su relacion con los edificios"
@startuml

abstract class Raza{
	-vida: Vida
	-construcciones: Construccion
	-unidades: Unidad
	{abstract}+recibirDanio()
}

class Zerg
abstract class Construccion
class Criadero
class Extractor
class ReservaDeProduccion
class Guarida
class Espiral
abstract class Unidad
class Larva
class Zangano {
    -cantidadRecolectablePorZangano: int
    +recolectarMineral()
}

Raza <|-- Zerg
Zerg --> Construccion
Construccion <|-- Criadero
Construccion <|-- Extractor
Construccion <|-- ReservaDeProduccion
Construccion <|-- Guarida
Construccion <|-- Espiral
Zerg --> Unidad
Unidad <|-- Larva
Unidad <|-- Zangano

@enduml

"-------------------------------------------------------"

"Criadero"
@startuml

class Criadero {
    -estadoOperativo: EstadoOperativo
    -maxLarvas: int
    +Criadero(Tiempo, EstadoOperativo, Moho)
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTiempo()
    +generarLarva(): Larva

}

interface Evolucionable{
	+evolucionar(UnidadRaza)
}

class Larva{
	+evolucionar(): Zangano
}

class Moho{
	-radio: int
	+expandirse()
}

class Tiempo{
	-cantidad: Int
	+Tiempo(cantidad)
	+avanzarTiempo()
	+tiempo(): Int
}

interface EstadoOperativo{
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTurno()
    +generarLarva(): Larva
}

class CriaderoUtilizable
class CriaderoNoUtilizable

Criadero --> EstadoOperativo
CriaderoUtilizable ..up|> EstadoOperativo
CriaderoNoUtilizable ..up|> EstadoOperativo

Tiempo <-right- Criadero
Larva ..|> Evolucionable
Criadero --> Larva
Criadero o-- Moho

@enduml

"Inicialmente el Criadero comenzara con un estado Operativo
de CriaderoNoUtilizable.
Si quisieramos pedirle a Criadero que cuenta las larvas,
dentro del metodo contarLarvas() hariamos algo como

estadoOperativo contarLarvas()

y utilizando de esta forma polimorfismo dependiendo
de su estado (que cambiara en tiempo de ejecucion)
la respuesta al mensaje sera diferente.
Estamos delegando en el estadoOperativo.

Por esta razon es que Criadero es una clase concreta.
Dentro de Criadero se delegaran los distintos tipos
de mensajes."

"--------------------------------------------------------"

"Raza Protoss y su relacion con los edificios"
@startuml

abstract class Raza{
	-vida: Vida
	-construcciones: Construccion
	-unidades: Unidad
	{abstract}+recibirDanio()
}

class Protoss
abstract class Construccion
class NexoMineral
class Pilon
class Asimilador
class Acceso
class PuertoEstelar

Raza <|-- Protoss
Protoss --> Construccion
Construccion <|-- NexoMineral
Construccion <|-- Pilon
Construccion <|-- Asimilador
Construccion <|-- Acceso
Construccion <|-- PuertoEstelar

@enduml

"--------------------------------------------------------"

"Recursos"
@startuml

class Mineral{
	-unidad: Unidad
	+disminuirUnidades(cantidad)
}
class Nodo
abstract class Gas
class Vespeno
class Volcan{
	-edificio: Construccion
	+Volcan(EdificioVacio)
	+construir(Construccion edificio)
	+extraerGas()
	+extraer(cantidadAExtraer)
}

class Geiser

interface Recolectable

Gas <|-- Vespeno


abstract class Unidad{
	-cantidad
	+Unidad(cantidad)
}

class Turno{
	- tie
}

@enduml

"--------------------------------------------------------"

"Edificios Zerg"
@startuml

interface Construible{
	+construir()
}
interface Destruible
interface Daniable
interface Recuperable
interface Evolucionable{
	+evolucionar(UnidadRaza)
}
interface Mutable
interface Creable
interface Edificable
interface Habilitable
interface Transformable

class Unidad
class Larva{
	+evolucionar(): Zangano
}

class Zangano
class Construccion
class Moho{
	-radio:Int
	+expandirse()
}
abstract class Criadero {
    -maxLarvas
    +Criadero(Tiempo)
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTurno()
    +generarLarva(): Larva
}

Criadero <|-- CriaderoUtilizable
Criadero <|-- CriaderoNoUtilizable

class Tiempo{
	-cantidad: Int
	+Tiempo(cantidad)
	+avanzarTiempo()
	+tiempo(): Int
}


Tiempo <-right- Criadero

Larva ..|> Evolucionable
Criadero --> Larva

abstract class RefineriaDeGas{
	-extraible:Int
	+RefineriaDeGas(cantidad)
	+extraerGas(Volcan)
}

class Extractor{
	-zanganos:Array<Zangano>
}

Extractor "1" --> Zangano

class Asimilador{
}

RefineriaDeGas <|--Extractor
RefineriaDeGas <|--Asimilador
class ReservaDeProduccion
class Guarida
class Espiral

Criadero o-- Moho

@enduml

"--------------------------------------------------------"


"Clases que tienen unidades que se gastan"
@startuml

abstract class Consumible{
	-cantidad: Int
}
Consumible <|-- Tiempo
Consumible <|-- Vida
Consumible <|-- Unidad
Consumible <|-- Escudo

class Tiempo{
	+Tiempo(cantidad: int)
	+pasarTiempo()
}

class Vida
class Unidad{
	
}
class Escudo

interface Consumible2

@enduml

"--------------------------------------------------------"


" Edificios Protoss"
@startuml

class Escudo
class Vida
class Pilon
class RadioDeAlcance
class NexoMineral
class MatrizPsi
class Asimilador
class CapsulaDeGas
class Acceso
class GrietaDistorcion
class Entrada
class Tropa
class Aiur
class PuertoEstelar


interface Daniable
interface Recuperable
interface Construible
interface Destruible
interface Edificable
interface Energizable
interface Emitible
interface Producible
interface Entrenable
interface Transportable


@enduml

"--------------------------------------------------------"


@startuml

abstract class Construccion

abstract class Criadero{
	+{abstract}metodo1()
	+{abstract}metodo2()
}
class CriaderoUtilizable
class CriaderoNoUtilizable

Construccion <|-- Utilizable
Construccion <|-- NoUtilizable

@enduml

"--------------------------------------------------------"

@startuml

Usuario->Mapa: construir(Construccion, Ubicacion)
	loop para cada ubicacion
		Mapa->Mapa: ubicacionBuscada = encontrarUbicacion(Ubicacion)
	end
	Mapa->Ubicacion:puedoConstruirEnEstaUbicacion()
	Ubicacion-->Mapa:true
	Mapa->Ubicacion: puedoConstruirEsteEdificio(Construccion)
	Ubicacion->Construccion: dameLoQueNecesitasParaConstruirte()
	Construccion-->Ubicacion: Moho/Pilon
	Ubicacion->Ubicacion: tengo(Moho/Pilon)
	Ubicacion-->Mapa:true
	Mapa->Ubicacion:crear(Construccion)
	
@enduml

"--------------------------------------------------------"

@startuml

Usuario->Mapa: construir(Construccion, Ubicacion)
	loop para cada ubicacion
		Mapa->Mapa: conRequisito = encontrarUbicacionConRequisito(Construccion)
	end
	loop para cada ubicacion con moho
		Mapa->Ubicacion:sePuedeConstruirEn(Ubicacion)
		Ubicacion->Ubicacion: estaDentroDeRadioDeConstruccion()
		Ubicacion-->Mapa:true
	end
	Mapa->Ubicacion:crear(Construccion)
	
@enduml

"--------------------------------------------------------"