
"Razas de los personajes que se extiende a los edificios"
@startuml

abstract class Raza{
	-vida: Vida
	{abstract}+recibirDanio()
}
class Protoss{
	-escudo: Escudo
}
Raza <|-- Zerg
Raza <|-- Protoss

abstract class Personaje
abstract class Construccion

Construccion *-- Raza
Personaje *-- Raza 



@enduml


"Recursos"
@startuml

class Mineral{
	-unidad: Unidad
	+disminuirUnidades(cantidad)
}
class Nodo
abstract class Gas
class Vespeno
class Volcan{
	-edificio: Construccion
	+Volcan(EdificioVacio)
	+construir(Construccion edificio)
	+extraerGas()
	+extraer(cantidadAExtraer)
}

class Geiser

interface Recolectable

Gas <|-- Vespeno


abstract class Unidad{
	-cantidad
	+Unidad(cantidad)
}

class Turno{
	- tie
}

@enduml

"Edificios Zerg"
@startuml

interface Construible{
	+construir()
}
interface Destruible
interface Daniable
interface Recuperable
interface Evolucionable{
	+evolucionar(UnidadRaza)
}
interface Mutable
interface Creable
interface Edificable
interface Habilitable
interface Transformable

class Unidad
class Larva{
	+evolucionar(): Zangano
}

class Zangano
class Construccion
class Moho{
	-radio:Int
	+expandirse()
}
abstract class Criadero {
    -maxLarvas
    +Criadero(Tiempo)
    +contarLarvas()
    +evolucionar(Larva)
    +avanzarTurno()
    +generarLarva(): Larva
}

Criadero <|-- CriaderoUtilizable
Criadero <|-- CriaderoNoUtilizable

class Tiempo{
	-cantidad: Int
	+Tiempo(cantidad)
	+avanzarTiempo()
	+tiempo(): Int
}



Tiempo <-right- Criadero

Larva ..|> Evolucionable
Criadero --> Larva

abstract class RefineriaDeGas{
	-extraible:Int
	+RefineriaDeGas(cantidad)
	+extraerGas(Volcan)
}

class Extractor{
	-zanganos:Array<Zangano>
}

Extractor "1" --> Zangano

class Asimilador{
}

RefineriaDeGas <|--Extractor
RefineriaDeGas <|--Asimilador
class ReservaDeProduccion
class Guarida
class Espiral

Criadero o-- Moho

@enduml


"Clases que tienen unidades que se gastan"
@startuml

abstract class Consumible{
	-cantidad: Int
}
Consumible <|-- Tiempo
Consumible <|-- Vida
Consumible <|-- Unidad
Consumible <|-- Escudo

class Tiempo{
	+Tiempo(cantidad: int)
	+pasarTiempo()
}

class Vida
class Unidad{
	
}
class Escudo

class Mapa{
	+construir(Construccion,Ubicacion)
	+encontrarUbicacionConRequisito(Construccion)
}

class Ubicacion{
	-posX: int
	-posY: int
	-elementos:Array
	+sePuedeConstruirEn(Ubicacion)
	+estaDentroDeRadioDeConstruccion()
	
}
Mapa *-- Ubicacion

interface Consumible2

@enduml


" Edificios Protoss"
@startuml

class Escudo
class Vida
class Pilon
class RadioDeAlcance
class NexoMineral
class MatrizPsi
class Asimilador
class CapsulaDeGas
class Acceso
class GrietaDistorcion
class Entrada
class Tropa
class Aiur
class PuertoEstelar


interface Daniable
interface Recuperable
interface Construible
interface Destruible
interface Edificable
interface Energizable
interface Emitible
interface Producible
interface Entrenable
interface Transportable


@enduml


@startuml

abstract class Construccion

abstract class Criadero{
	+{abstract}metodo1()
	+{abstract}metodo2()
}
class CriaderoUtilizable
class CriaderoNoUtilizable

Construccion <|-- Utilizable
Construccion <|-- NoUtilizable

@enduml

@startuml

Usuario->Mapa: construir(Construccion, Ubicacion)
	loop para cada ubicacion
		Mapa->Mapa: ubicacionBuscada = encontrarUbicacion(Ubicacion)
	end
	Mapa->Ubicacion:puedoConstruirEnEstaUbicacion()
	Ubicacion-->Mapa:true
	Mapa->Ubicacion: puedoConstruirEsteEdificio(Construccion)
	Ubicacion->Construccion: dameLoQueNecesitasParaConstruirte()
	Construccion-->Ubicacion: Moho/Pilon
	Ubicacion->Ubicacion: tengo(Moho/Pilon)
	Ubicacion-->Mapa:true
	Mapa->Ubicacion:crear(Construccion)
	
@enduml

@startuml

Usuario->Mapa: construir(Construccion, Ubicacion)
	loop para cada ubicacion
		Mapa->Mapa: conRequisito = encontrarUbicacionConRequisito(Construccion)
	end
	loop para cada ubicacion con moho
		Mapa->Ubicacion:sePuedeConstruirEn(Ubicacion)
		Ubicacion->Ubicacion: estaDentroDeRadioDeConstruccion()
		Ubicacion-->Mapa:true
	end
	Mapa->Ubicacion:crear(Construccion)
	
@enduml